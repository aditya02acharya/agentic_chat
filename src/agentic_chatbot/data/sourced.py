"""Sourced content - ContentBlock with provenance tracking.

SourcedContent wraps a ContentBlock with information about its origin,
enabling citation generation and debugging.

Design Principles:
- Wraps ContentBlock without modifying it
- Tracks source, query, and relevance
- Generates citation references
- Supports summarization for context optimization
"""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from typing import Any

from agentic_chatbot.data.content import ContentBlock, TextContent


@dataclass(frozen=True)
class ContentSource:
    """
    Source information for content provenance.

    Tracks where content came from and how it was retrieved.
    """

    # Identity
    source_id: str  # Unique ID, e.g., "web_search_1", "rag_2"
    source_type: str  # Tool/operator name, e.g., "web_search", "rag_search"

    # Context
    query_used: str = ""  # What query was used to retrieve this
    server_id: str = ""  # MCP server ID if applicable

    # Timing
    timestamp: datetime = field(default_factory=datetime.utcnow)

    # Optional relevance (if tool provides it)
    relevance_score: float | None = None  # 0.0 - 1.0

    def __str__(self) -> str:
        return f"{self.source_type}[{self.source_id}]"


@dataclass
class SourcedContent:
    """
    ContentBlock with provenance tracking.

    Wraps content with source information for:
    - Citation generation (footnotes)
    - Context optimization (summarization)
    - Debugging (tracing data flow)

    Usage:
        # Create sourced content
        source = ContentSource("web_search_1", "web_search", query_used="python async")
        content = TextContent.markdown("# Results\n...")
        sourced = SourcedContent(content=content, source=source)

        # Generate citation
        ref = sourced.footnote_ref  # "[^web_search_1]"
        block = sourced.citation_block  # "[^web_search_1]: Source: web_search..."
    """

    content: ContentBlock
    source: ContentSource

    # Summary (generated by LLM for supervisor context)
    _summary: "ContentSummary | None" = field(default=None, repr=False)

    @property
    def source_id(self) -> str:
        """Get source ID."""
        return self.source.source_id

    @property
    def source_type(self) -> str:
        """Get source type."""
        return self.source.source_type

    @property
    def text(self) -> str:
        """Get content as text."""
        return self.content.as_text

    # Citation methods
    @property
    def footnote_ref(self) -> str:
        """Get footnote reference marker for inline citation."""
        return f"[^{self.source.source_id}]"

    @property
    def citation_block(self) -> str:
        """Get full citation block for footnotes section."""
        lines = [f"[^{self.source.source_id}]: Source: {self.source.source_type}"]
        if self.source.query_used:
            lines.append(f"  Query: {self.source.query_used}")
        return "\n".join(lines)

    # Summary methods
    @property
    def summary(self) -> "ContentSummary | None":
        """Get LLM-generated summary."""
        return self._summary

    def set_summary(self, summary: "ContentSummary") -> None:
        """Set the summary (called after LLM summarization)."""
        self._summary = summary

    @property
    def has_summary(self) -> bool:
        """Check if content has been summarized."""
        return self._summary is not None

    def to_supervisor_text(self) -> str:
        """
        Get text for supervisor context.

        Returns summary if available, otherwise truncated content.
        """
        if self._summary:
            return self._summary.to_supervisor_text(self.source)
        # Fallback: truncated content
        text = self.content.as_text
        if len(text) > 500:
            text = text[:500] + "..."
        return f"**{self.source.source_type}** [{self.source.source_id}]:\n{text}"

    # Serialization
    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        d = {
            "content": self.content.to_dict(),
            "source": {
                "source_id": self.source.source_id,
                "source_type": self.source.source_type,
                "query_used": self.source.query_used,
                "server_id": self.source.server_id,
                "timestamp": self.source.timestamp.isoformat(),
                "relevance_score": self.source.relevance_score,
            },
        }
        if self._summary:
            d["summary"] = self._summary.to_dict()
        return d


@dataclass
class ContentSummary:
    """
    LLM-generated summary of SourcedContent.

    Created by summarizer (haiku) for supervisor context optimization.
    Supervisor sees these instead of raw content.
    """

    # Core summary
    executive_summary: str  # One-line summary
    key_findings: list[str] = field(default_factory=list)  # Bullet points

    # Status
    has_useful_data: bool = True  # Did the source return useful data?
    error: str | None = None  # Error if data retrieval failed

    # Task context (what was this summary for)
    task_description: str = ""

    def to_supervisor_text(self, source: ContentSource) -> str:
        """Format for supervisor's context window."""
        if self.error:
            return f"**{source.source_type}** [{source.source_id}]: âŒ Error - {self.error}"

        if not self.has_useful_data:
            return f"**{source.source_type}** [{source.source_id}]: No useful results"

        findings = "\n".join(f"  - {f}" for f in self.key_findings[:3])
        return f"**{source.source_type}** [{source.source_id}]: {self.executive_summary}\n{findings}"

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "executive_summary": self.executive_summary,
            "key_findings": self.key_findings,
            "has_useful_data": self.has_useful_data,
            "error": self.error,
            "task_description": self.task_description,
        }


# =============================================================================
# FACTORY FUNCTIONS
# =============================================================================


def create_sourced_content(
    content: str | ContentBlock,
    source_type: str,
    source_id: str | None = None,
    query_used: str = "",
    server_id: str = "",
    relevance_score: float | None = None,
) -> SourcedContent:
    """
    Create SourcedContent from raw content.

    Args:
        content: Text string or ContentBlock
        source_type: Tool/operator name
        source_id: Unique ID (auto-generated if not provided)
        query_used: Query that produced this content
        server_id: MCP server ID
        relevance_score: Optional relevance score

    Returns:
        SourcedContent with provenance
    """
    # Convert string to ContentBlock
    if isinstance(content, str):
        content = TextContent.markdown(content)

    # Generate source ID if not provided
    if source_id is None:
        import time

        source_id = f"{source_type}_{int(time.time() * 1000) % 100000}"

    source = ContentSource(
        source_id=source_id,
        source_type=source_type,
        query_used=query_used,
        server_id=server_id,
        relevance_score=relevance_score,
    )

    return SourcedContent(content=content, source=source)
